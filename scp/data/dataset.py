# AUTOGENERATED! DO NOT EDIT! File to edit: nb_data.dataset.ipynb (unless otherwise specified).

__all__ = ['MultiLabelDataFrameImageDataset', 'DataFrameImageDataset']

# Cell
import os
import numpy as np
from ..utils.general import t2p
import cv2
import matplotlib.pyplot as plt
import math
import PIL
import torch
from torch.utils.data import Dataset
from collections import Counter

class MultiLabelDataFrameImageDataset(Dataset):
    '''Build an image dataset from a dataframe.

    Images are opened as numpy arrays (cv2) so that albumentation
    transformations can be used.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe containing image paths and corresponding labels (optional)

    img_col : str
        Name of df column containing image paths

    label_col : str; optional
        Name of df column containing image labels.
        If None, ´self.label_col´ are all zeros.

    root : str; optional
        Top-level directory that gets prepended to image paths

    img_transform : callable; optional
        Composition of albumentation transforms (or any transforms that work on numpy arrays)

    label_names : list; optional
        List of unique label names. Order of list determines what integer a label is mapped to.
        If None, ´self.label_names´ are determined by ´self.label´.

    Attributes
    ----------
    label_to_int : dict
        Mapping between label names and integers.

    int_to_label : dict
        Mapping between integers and labels.

    num_labels : int
        Number of unique labels
    '''
    def __init__(
        self,
        df,
        img_col,
        label_cols,
        root="./",
        img_transform=None,
        label_class_names=None
    ):
        self.imgs = list(df[img_col])
        self.label_cols = label_cols if isinstance(label_cols, list) else [label_cols,] # listify
        self.root = root
        self.img_transform = img_transform
        label_class_names = label_class_names if isinstance(label_class_names, list) else [label_class_names,] # listiy

        # create additional attributes
        self.labels = dict()
        self.label_class_names = dict()
        self.label_to_int = dict()
        self.int_to_label = dict()
        for idx, label_col in enumerate(self.label_cols):
            self.labels[label_col] = list(df[label_col]) if label_col is not None else [0,]*len(self.imgs)
            if idx < len(label_class_names) and label_class_names[idx] is not None:
                self.label_class_names[label_col] = label_class_names[idx]
            else:
                self.label_class_names[label_col] = sorted(set(self.labels[label_col]))
            self.label_to_int[label_col] = {k:v for v, k in enumerate(self.label_class_names[label_col])}
            self.int_to_label[label_col] = {v:k for k, v in self.label_to_int[label_col].items()}

        self.n_labels = len(self.label_cols) # how many labels/targets there are
        self.classes_per_label = {k:len(v) for k, v in self.label_class_names.items()} # how many distinct classes for each label

    def __len__(self):
        return len(self.imgs)

    def __getitem__(self, idx):
        img = cv2.imread(os.path.join(self.root, self.imgs[idx]))
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        multi_label = tuple()
        for label_col, labels in self.labels.items():
            multi_label = multi_label + (self.label_to_int[label_col][labels[idx]],)

        if self.img_transform:
            img = self.img_transform(image=img)["image"]

        return (img,) + multi_label

    def __repr__(self):
        info = ""
        info += f"Number of images\t: {self.__len__()}\n"
        for label_col, label_to_int in self.label_to_int.items():
            info += f"\nNumber of '{label_col}' labels\t: {len(label_to_int)}\n"
            for k, v in label_to_int.items():
                info += f"-> {k} ({Counter(self.labels[label_col])[k]})\n"
        if self.img_transform:
            info += "\nImage transformations:\n"
            info += f"{self.img_transform.__repr__()}\n"
        return info

    def get_labels(self):
        '''Label getter function required for compatibility with various modules (Balancer)'''
        return self.labels[self.label_cols[0]] # defaults to first label type

    def get_n_items(self, n, random=False):
        idxs = np.arange(n)
        if random:
            idxs = np.random.choice(self.__len__(), n, replace=False)

        items = list()
        for idx in idxs:
            items.append(self.__getitem__(idx))

        return items

    def convert_to_pil_img(self, img):
        if isinstance(img, PIL.Image.Image):
            return img
        elif isinstance(img, np.ndarray):
            return PIL.Image.fromarray(img)
        elif isinstance(img, torch.Tensor):
            return t2p(img)
        else:
            raise TypeError(f"Conversion from {type(img)} to pillow image not possible")

    def show_n_items(self, n=9, random=False, figsize=(10, 10)):
        items = self.get_n_items(n, random)
        fig, axes = plt.subplots(math.ceil(n/3), 3, figsize=figsize)
        for ax, item in zip(axes.flatten(), items):
            img = self.convert_to_pil_img(item[0])
            multi_label = list()
            for idx, (label_col, int_to_label) in enumerate(self.int_to_label.items()):
                multi_label.append(int_to_label[item[idx+1]])

            ax.set_title(f"{multi_label}")
            ax.imshow(img)
            ax.axis('off')


class DataFrameImageDataset(Dataset):
    '''Build an image dataset from a dataframe.

    Images are opened as numpy arrays (cv2) so that albumentation
    transformations can be used.

    Parameters
    ----------
    df : pd.DataFrame
        Dataframe containing image paths and corresponding labels (optional)

    img_col : str
        Name of df column containing image paths

    label_col : str; optional
        Name of df column containing image labels.
        If None, ´self.label_col´ are all zeros.

    root : str; optional
        Top-level directory that gets prepended to image paths

    img_transform : callable; optional
        Composition of albumentation transforms (or any transforms that work on numpy arrays)

    label_names : list; optional
        List of unique label names. Order of list determines what integer a label is mapped to.
        If None, ´self.label_names´ are determined by ´self.label´.

    Attributes
    ----------
    label_to_int : dict
        Mapping between label names and integers.

    int_to_label : dict
        Mapping between integers and labels.

    num_labels : int
        Number of unique labels
    '''
    def __init__(
        self,
        df,
        img_col,
        label_col=None,
        root="./",
        img_transform=None,
        label_names=None
    ):
        self.imgs = list(df[img_col])
        self.labels = list(df[label_col]) if label_col is not None else [0,]*len(self.imgs)
        self.root = root
        self.img_transform = img_transform
        self.label_names = label_names if label_names is not None else sorted(set(self.labels))
        self.label_to_int = {k:v for v, k in enumerate(self.label_names)}
        self.int_to_label = {v: k for k, v in self.label_to_int.items()}
        self.num_labels = len(self.label_names)

    def __len__(self):
        return len(self.imgs)

    def __getitem__(self, idx):
        img = cv2.imread(os.path.join(self.root, self.imgs[idx]))
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        label = self.label_to_int[self.labels[idx]]
        if self.img_transform:
            img = self.img_transform(image=img)["image"]
        return img, label

    def __repr__(self):
        info = ""
        info += f"Number of images\t: {self.__len__()}\n"
        info += f"Number of labels\t: {len(self.label_to_int)}\n"
        for k, v in self.label_to_int.items():
            info += f"-> {k} ({Counter(self.labels)[k]})\n"
        if self.img_transform:
            info += "\nImage transformations:\n"
            info += f"{self.img_transform.__repr__()}\n"
        return info

    def get_labels(self):
        '''Label getter function required for compatibility with various modules'''
        return self.labels

    def get_n_items(self, n, random=False):
        idxs = np.arange(n)
        if random:
            idxs = np.random.choice(self.__len__(), n, replace=False)

        items = list()
        for idx in idxs:
            items.append(self.__getitem__(idx))

        return items

    def convert_to_pil_img(self, img):
        if isinstance(img, PIL.Image.Image):
            return img
        elif isinstance(img, np.ndarray):
            return PIL.Image.fromarray(img)
        elif isinstance(img, torch.Tensor):
            return t2p(img)
        else:
            raise TypeError(f"Conversion from {type(img)} to pillow image not possible")

    def show_n_items(self, n=9, random=False, figsize=(10, 10)):
        items = self.get_n_items(n, random)
        fig, axes = plt.subplots(math.ceil(n/3), 3, figsize=figsize)
        for ax, item in zip(axes.flatten(), items):
            img, label = self.convert_to_pil_img(item[0]), self.int_to_label[item[1]]
            ax.set_title(label)
            ax.imshow(img)
            ax.axis('off')