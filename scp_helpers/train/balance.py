# AUTOGENERATED! DO NOT EDIT! File to edit: 00_train.balance.ipynb (unless otherwise specified).

__all__ = ['downsample_df', 'upsample_df', 'balance_df']

# Cell
import pandas as pd
import numpy as np

# Cell
def downsample_df(df:pd.DataFrame, y_column:str, min_size:int=None, random_state:int=115, **kwargs) -> pd.DataFrame:
    '''Balance classes of the target variable by downsampling all classes to be equal to or smaller than "min_size".

    Classes smaller than "min_size" are not affected and will remain at their current size. If "min_size" is ommitted,
    the size of the smallest current class is taken as "min_size". TEST.
    '''
    df_new = df.copy()#.reset_index(drop=True)

    # get smallest current class if not supplied
    if min_size == None:
        min_size = df_new[y_column].value_counts().min()

    # downsample all classes larger than min_size
    for class_index, group in df_new.groupby(y_column):
        if group.shape[0] > min_size:
            drop_idx = group.sample(len(group)-min_size, random_state=random_state, **kwargs).index
            df_new = df_new.drop(drop_idx)

    return df_new.reset_index(drop=True)

# Cell

def upsample_df(df:pd.DataFrame, y_column:str, max_size:int=None, random_state:int=115, **kwargs) -> pd.DataFrame:
    '''Balance classes of the target variable by upsampling all classes to be equal to or larger than "max_size".

    Classes larger than "max_size" are not affected and will remain at their current size. If "max_size" is ommitted,
    the size of the largest class is taken as "max_size".
    '''
    df_new = df.copy()#.reset_index(drop=True)

    # get largest current class if not supplied
    if max_size == None:
        max_size = df_new[y_column].value_counts().max()

    # upsample all classes smaller than max_size
    for class_index, group in df_new.groupby(y_column):
        if group.shape[0] < max_size:
            df_new = df_new.append(group.sample(max_size-len(group), replace=True, random_state=random_state, **kwargs))

    return df_new.reset_index(drop=True)

# Cell

def balance_df(df:pd.DataFrame, y_column:str, size:int, random_state:int=115, **kwargs) -> pd.DataFrame:
    '''Balance classes of the target variable by up- or downsampling all classes to be equal to "size".
    '''
    df_new = df.copy().reset_index(drop=True)

    for class_index, group in df_new.groupby(y_column):
        if group.shape[0] < size:
            df_new = df_new.append(group.sample(size-len(group), replace=True, random_state=random_state, **kwargs))
        if group.shape[0] > size:
            drop_idx = group.sample(len(group)-size, random_state=random_state, **kwargs).index
            df_new = df_new.drop(drop_idx)

    return df_new.reset_index(drop=True)